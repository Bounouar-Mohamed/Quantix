generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Channel {
  chat
  realtime
}

enum BillingStatus {
  pending
  invoiced
  paid
  overdue
}

// ═══════════════════════════════════════════════════════════════════════════════
// CLIENTS / TENANTS
// ═══════════════════════════════════════════════════════════════════════════════

model Tenant {
  id          String   @id @default(cuid())
  name        String   // Ex: "Reccos"
  slug        String   @unique // Ex: "reccos"
  email       String?  // Contact email
  description String?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  pricing     TenantPricing?
  usage       TenantUsage[]
  billing     TenantBilling[]

  @@index([slug])
}

// Configuration tarifaire par client (ce qu'on leur facture)
model TenantPricing {
  id               String   @id @default(cuid())
  tenantId         String   @unique
  tenant           Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // MODÈLE DE FACTURATION PRINCIPAL
  // ═══════════════════════════════════════════════════════════════════════════════
  billingModel     String   @default("per_user")  // "per_user", "per_request", "per_token", "flat"
  pricePerUser     Float    @default(200)         // Prix par utilisateur actif (ex: $200/user)
  flatMonthlyFee   Float    @default(0)           // Forfait mensuel fixe
  
  // ═══════════════════════════════════════════════════════════════════════════════
  // TARIFS ALTERNATIFS (si billingModel != "per_user")
  // ═══════════════════════════════════════════════════════════════════════════════
  chatPricePerRequest    Float    @default(0)     // Prix par requête chat
  chatPricePerToken      Float    @default(0)     // Prix par 1K tokens chat
  realtimePricePerMinute Float    @default(0)     // Prix par minute realtime
  realtimePricePerRequest Float   @default(0)     // Prix par requête realtime
  
  // Options
  includesSupport   Boolean  @default(true)
  monthlyMinimum    Float    @default(0)    // Minimum mensuel garanti
  discountPercent   Float    @default(0)    // Remise en %
  
  // Limites
  maxRequestsPerDay    Int?   // Limite quotidienne
  maxTokensPerDay      Int?   // Limite tokens quotidienne
  maxUsersAllowed      Int?   // Limite utilisateurs
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// Consommation agrégée par client et période
model TenantUsage {
  id          String   @id @default(cuid())
  tenantId    String
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  period      String   // Format: "2025-01" (YYYY-MM)
  
  // Métriques Chat
  chatRequests      Int      @default(0)
  chatTokensIn      Int      @default(0)
  chatTokensOut     Int      @default(0)
  chatTotalTokens   Int      @default(0)
  
  // Métriques Realtime
  realtimeRequests  Int      @default(0)
  realtimeMinutes   Float    @default(0)
  
  // Coûts (ce qu'on paie à OpenAI)
  costOpenAI        Float    @default(0)
  
  // Revenus (ce qu'on facture au client)
  revenueChat       Float    @default(0)
  revenueRealtime   Float    @default(0)
  revenueTotal      Float    @default(0)
  
  // Utilisateurs uniques ce mois
  uniqueUsers       Int      @default(0)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([tenantId, period])
  @@index([tenantId])
  @@index([period])
}

// Facturation par période
model TenantBilling {
  id          String        @id @default(cuid())
  tenantId    String
  tenant      Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  period      String        // Format: "2025-01"
  
  // Montants
  subtotal    Float         @default(0)  // Avant remise
  discount    Float         @default(0)  // Montant remise
  total       Float         @default(0)  // Après remise
  costOpenAI  Float         @default(0)  // Nos coûts
  profit      Float         @default(0)  // Bénéfice = total - costOpenAI
  margin      Float         @default(0)  // Marge en %
  
  status      BillingStatus @default(pending)
  invoiceRef  String?       // Référence facture
  invoicedAt  DateTime?
  paidAt      DateTime?
  
  notes       String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([tenantId, period])
  @@index([tenantId])
  @@index([period])
  @@index([status])
}

// ═══════════════════════════════════════════════════════════════════════════════
// USAGE INDIVIDUEL (existant, avec relations mises à jour)
// ═══════════════════════════════════════════════════════════════════════════════

model UserUsage {
  id           String   @id @default(cuid())
  userId       String
  tenantId     String?
  firstSeen    DateTime @default(now())
  lastSeen     DateTime @updatedAt
  requests     Int      @default(0)
  tokensIn     Int      @default(0)
  tokensOut    Int      @default(0)
  totalTokens  Int      @default(0)
  totalCost    Float    @default(0)
  channel      Channel

  @@index([tenantId])
  @@index([userId])
}

model SessionUsage {
  id             String   @id @default(cuid())
  sessionId      String?
  conversationId String?
  userId         String
  tenantId       String?
  model          String
  channel        Channel
  startAt        DateTime @default(now())
  endAt          DateTime?
  durationMs     Int?
  tokensIn       Int      @default(0)
  tokensOut      Int      @default(0)
  totalCost      Float    @default(0)

  @@index([tenantId])
  @@index([userId])
}

model EventUsage {
  id        String   @id @default(cuid())
  ts        DateTime @default(now())
  userId    String?
  tenantId  String?
  sessionId String?
  type      String
  meta      Json?

  @@index([tenantId])
  @@index([type])
}

model ConversationThread {
  id                String   @id @default(cuid())
  tenantId          String?
  conversationId    String
  assistantThreadId String
  assistantId       String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@unique([tenantId, conversationId])
  @@index([conversationId])
  @@index([tenantId])
}
